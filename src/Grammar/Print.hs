-- File generated by the BNF Converter (bnfc 2.9.5).
{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Grammar.
module Grammar.Print where

import Data.Char (Char, isSpace)
import qualified Grammar.Abs
import Prelude (
    Bool (..),
    Double,
    Int,
    Integer,
    ShowS,
    String,
    all,
    elem,
    foldr,
    id,
    map,
    null,
    replicate,
    showChar,
    showString,
    shows,
    span,
    ($),
    (*),
    (+),
    (++),
    (-),
    (.),
    (<),
    (==),
 )

-- | The top-level printing method.
printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
    rend ::
        Int -> -- \^ Indentation level.
        Bool -> -- \^ Pending indentation to be output before next character?
        [String] ->
        ShowS
    rend i p = \case
        "[" : ts -> char '[' . rend i False ts
        "(" : ts -> char '(' . rend i False ts
        "{" : ts -> onNewLine i p . showChar '{' . new (i + 1) ts
        "}" : ";" : ts -> onNewLine (i - 1) p . showString "};" . new (i - 1) ts
        "}" : ts -> onNewLine (i - 1) p . showChar '}' . new (i - 1) ts
        [";"] -> char ';'
        ";" : ts -> char ';' . new i ts
        t : ts@(s : _)
            | closingOrPunctuation s ->
                pending . showString t . rend i False ts
        t : ts -> pending . space t . rend i False ts
        [] -> id
      where
        -- Output character after pending indentation.
        char :: Char -> ShowS
        char c = pending . showChar c

        -- Output pending indentation.
        pending :: ShowS
        pending = if p then indent i else id

    -- Indentation (spaces) for given indentation level.
    indent :: Int -> ShowS
    indent i = replicateS (2 * i) (showChar ' ')

    -- Continue rendering in new line with new indentation.
    new :: Int -> [String] -> ShowS
    new j ts = showChar '\n' . rend j True ts

    -- Make sure we are on a fresh line.
    onNewLine :: Int -> Bool -> ShowS
    onNewLine i p = (if p then id else showChar '\n') . indent i

    -- Separate given string from following text by a space (if needed).
    space :: String -> ShowS
    space t s =
        case (all isSpace t, null spc, null rest) of
            (True, _, True) -> [] -- remove trailing space
            (False, _, True) -> t -- remove trailing space
            (False, True, False) -> t ++ ' ' : s -- add space if none
            _ -> t ++ s
      where
        (spc, rest) = span isSpace s

    closingOrPunctuation :: String -> Bool
    closingOrPunctuation [c] = c `elem` closerOrPunct
    closingOrPunctuation _ = False

    closerOrPunct :: String
    closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.
class Print a where
    prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
    prt i = concatD . map (prt i)

instance Print Char where
    prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
    prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
    s | s == q -> showChar '\\' . showChar s
    '\\' -> showString "\\\\"
    '\n' -> showString "\\n"
    '\t' -> showString "\\t"
    s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
    prt _ x = doc (shows x)

instance Print Double where
    prt _ x = doc (shows x)

instance Print Grammar.Abs.Ident where
    prt _ (Grammar.Abs.Ident i) = doc $ showString i
instance Print (Grammar.Abs.Program' a) where
    prt i = \case
        Grammar.Abs.Program _ topdefs -> prPrec i 0 (concatD [prt 0 topdefs])

instance Print (Grammar.Abs.TopDef' a) where
    prt i = \case
        Grammar.Abs.TDFunction _ type_ id_ functionargs stmtblock -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString "("), prt 0 functionargs, doc (showString ")"), prt 0 stmtblock])
        Grammar.Abs.TDClass _ id_ classderivation classblock -> prPrec i 0 (concatD [doc (showString "class"), prt 0 id_, prt 0 classderivation, prt 0 classblock])

instance Print [Grammar.Abs.TopDef' a] where
    prt _ [] = concatD []
    prt _ [x] = concatD [prt 0 x]
    prt _ (x : xs) = concatD [prt 0 x, prt 0 xs]

instance Print (Grammar.Abs.FunctionArg' a) where
    prt i = \case
        Grammar.Abs.FArg _ type_ id_ -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_])

instance Print [Grammar.Abs.FunctionArg' a] where
    prt _ [] = concatD []
    prt _ [x] = concatD [prt 0 x]
    prt _ (x : xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Grammar.Abs.ClassDerivation' a) where
    prt i = \case
        Grammar.Abs.CDerive _ id_ -> prPrec i 0 (concatD [doc (showString "extends"), prt 0 id_])
        Grammar.Abs.CNoDerive _ -> prPrec i 0 (concatD [])

instance Print (Grammar.Abs.ClassBlock' a) where
    prt i = \case
        Grammar.Abs.ClassBlock _ classelems -> prPrec i 0 (concatD [doc (showString "{"), prt 0 classelems, doc (showString "}")])

instance Print (Grammar.Abs.ClassElem' a) where
    prt i = \case
        Grammar.Abs.CEMethod _ type_ id_ functionargs stmtblock -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString "("), prt 0 functionargs, doc (showString ")"), prt 0 stmtblock])
        Grammar.Abs.CEField _ type_ id_ -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString ";")])

instance Print [Grammar.Abs.ClassElem' a] where
    prt _ [] = concatD []
    prt _ (x : xs) = concatD [prt 0 x, prt 0 xs]

instance Print (Grammar.Abs.StmtBlock' a) where
    prt i = \case
        Grammar.Abs.StmtBlock _ stmts -> prPrec i 0 (concatD [doc (showString "{"), prt 0 stmts, doc (showString "}")])

instance Print [Grammar.Abs.Stmt' a] where
    prt _ [] = concatD []
    prt _ (x : xs) = concatD [prt 0 x, prt 0 xs]

instance Print (Grammar.Abs.Stmt' a) where
    prt i = \case
        Grammar.Abs.SEmpty _ -> prPrec i 0 (concatD [doc (showString ";")])
        Grammar.Abs.SBlock _ stmtblock -> prPrec i 0 (concatD [prt 0 stmtblock])
        Grammar.Abs.SDecl _ type_ declarations -> prPrec i 0 (concatD [prt 0 type_, prt 0 declarations, doc (showString ";")])
        Grammar.Abs.SAss _ id_ expr -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 expr, doc (showString ";")])
        Grammar.Abs.SIncr _ id_ -> prPrec i 0 (concatD [prt 0 id_, doc (showString "++"), doc (showString ";")])
        Grammar.Abs.SDecr _ id_ -> prPrec i 0 (concatD [prt 0 id_, doc (showString "--"), doc (showString ";")])
        Grammar.Abs.SRet _ expr -> prPrec i 0 (concatD [doc (showString "return"), prt 0 expr, doc (showString ";")])
        Grammar.Abs.SVRet _ -> prPrec i 0 (concatD [doc (showString "return"), doc (showString ";")])
        Grammar.Abs.SCond _ expr stmt -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 stmt])
        Grammar.Abs.SCondElse _ expr stmt1 stmt2 -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 stmt1, doc (showString "else"), prt 0 stmt2])
        Grammar.Abs.SWhile _ expr stmt -> prPrec i 0 (concatD [doc (showString "while"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 stmt])
        Grammar.Abs.SFor _ type_ id_ expr stmt -> prPrec i 0 (concatD [doc (showString "for"), doc (showString "("), prt 0 type_, prt 0 id_, doc (showString ":"), prt 0 expr, doc (showString ")"), prt 0 stmt])
        Grammar.Abs.SExp _ expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ";")])

instance Print (Grammar.Abs.Declaration' a) where
    prt i = \case
        Grammar.Abs.DeclNoInit _ id_ -> prPrec i 0 (concatD [prt 0 id_])
        Grammar.Abs.DeclInit _ id_ expr -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 expr])

instance Print [Grammar.Abs.Declaration' a] where
    prt _ [] = concatD []
    prt _ [x] = concatD [prt 0 x]
    prt _ (x : xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Grammar.Abs.Type' a) where
    prt i = \case
        Grammar.Abs.TInt _ -> prPrec i 0 (concatD [doc (showString "int")])
        Grammar.Abs.TStr _ -> prPrec i 0 (concatD [doc (showString "string")])
        Grammar.Abs.TBool _ -> prPrec i 0 (concatD [doc (showString "boolean")])
        Grammar.Abs.TVoid _ -> prPrec i 0 (concatD [doc (showString "void")])
        Grammar.Abs.TClass _ id_ -> prPrec i 0 (concatD [prt 0 id_])
        Grammar.Abs.TArr _ type_ -> prPrec i 0 (concatD [prt 0 type_, doc (showString "[]")])
        Grammar.Abs.TFun _ type_ types -> prPrec i 0 (concatD [prt 0 type_, doc (showString "("), prt 0 types, doc (showString ")")])

instance Print [Grammar.Abs.Type' a] where
    prt _ [] = concatD []
    prt _ [x] = concatD [prt 0 x]
    prt _ (x : xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Grammar.Abs.Expr' a) where
    prt i = \case
        Grammar.Abs.EVar _ id_ -> prPrec i 6 (concatD [prt 0 id_])
        Grammar.Abs.ELitInt _ n -> prPrec i 6 (concatD [prt 0 n])
        Grammar.Abs.ELitTrue _ -> prPrec i 6 (concatD [doc (showString "true")])
        Grammar.Abs.ELitFalse _ -> prPrec i 6 (concatD [doc (showString "false")])
        Grammar.Abs.EString _ str -> prPrec i 6 (concatD [printString str])
        Grammar.Abs.ENeg _ expr -> prPrec i 5 (concatD [doc (showString "-"), prt 6 expr])
        Grammar.Abs.ENot _ expr -> prPrec i 5 (concatD [doc (showString "!"), prt 6 expr])
        Grammar.Abs.EMul _ expr1 opmul expr2 -> prPrec i 4 (concatD [prt 4 expr1, prt 0 opmul, prt 5 expr2])
        Grammar.Abs.EAdd _ expr1 opadd expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 opadd, prt 4 expr2])
        Grammar.Abs.ERel _ expr1 oprel expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 oprel, prt 3 expr2])
        Grammar.Abs.EAnd _ expr1 expr2 -> prPrec i 1 (concatD [prt 2 expr1, doc (showString "&&"), prt 1 expr2])
        Grammar.Abs.EOr _ expr1 expr2 -> prPrec i 0 (concatD [prt 1 expr1, doc (showString "||"), prt 0 expr2])
        Grammar.Abs.ENullReg _ id_ -> prPrec i 6 (concatD [doc (showString "("), prt 0 id_, doc (showString ")"), doc (showString "null")])
        Grammar.Abs.ENullArr _ id_ -> prPrec i 6 (concatD [doc (showString "("), prt 0 id_, doc (showString "[]"), doc (showString ")"), doc (showString "null")])
        Grammar.Abs.ENull _ type_ -> prPrec i 6 (concatD [doc (showString "("), prt 0 type_, doc (showString ")"), doc (showString "null")])
        Grammar.Abs.ENew _ type_ -> prPrec i 6 (concatD [doc (showString "new"), prt 0 type_])
        Grammar.Abs.ENewArr _ type_ expr -> prPrec i 6 (concatD [doc (showString "new"), prt 0 type_, doc (showString "["), prt 0 expr, doc (showString "]")])
        Grammar.Abs.EApp _ expr exprs -> prPrec i 6 (concatD [prt 6 expr, doc (showString "("), prt 0 exprs, doc (showString ")")])
        Grammar.Abs.EMember _ expr id_ -> prPrec i 6 (concatD [prt 6 expr, doc (showString "."), prt 0 id_])

instance Print (Grammar.Abs.Epxr' a) where
    prt i = \case
        Grammar.Abs.EArrAcc _ expr exprs -> prPrec i 6 (concatD [prt 6 expr, doc (showString "["), prt 0 exprs, doc (showString "]")])

instance Print [Grammar.Abs.Expr' a] where
    prt _ [] = concatD []
    prt _ [x] = concatD [prt 0 x]
    prt _ (x : xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Grammar.Abs.OpAdd' a) where
    prt i = \case
        Grammar.Abs.Plus _ -> prPrec i 0 (concatD [doc (showString "+")])
        Grammar.Abs.Minus _ -> prPrec i 0 (concatD [doc (showString "-")])

instance Print (Grammar.Abs.OpMul' a) where
    prt i = \case
        Grammar.Abs.Times _ -> prPrec i 0 (concatD [doc (showString "*")])
        Grammar.Abs.Div _ -> prPrec i 0 (concatD [doc (showString "/")])
        Grammar.Abs.Mod _ -> prPrec i 0 (concatD [doc (showString "%")])

instance Print (Grammar.Abs.OpRel' a) where
    prt i = \case
        Grammar.Abs.LTH _ -> prPrec i 0 (concatD [doc (showString "<")])
        Grammar.Abs.LE _ -> prPrec i 0 (concatD [doc (showString "<=")])
        Grammar.Abs.GTH _ -> prPrec i 0 (concatD [doc (showString ">")])
        Grammar.Abs.GE _ -> prPrec i 0 (concatD [doc (showString ">=")])
        Grammar.Abs.EQU _ -> prPrec i 0 (concatD [doc (showString "==")])
        Grammar.Abs.NE _ -> prPrec i 0 (concatD [doc (showString "!=")])
