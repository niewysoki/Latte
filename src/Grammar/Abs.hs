-- File generated by the BNF Converter (bnfc 2.9.5).
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Latte.
module Grammar.Abs where

import qualified Data.String
import Prelude (Integer, String)
import qualified Prelude as C (
    Eq,
    Foldable,
    Functor,
    Int,
    Maybe (..),
    Ord,
    Read,
    Show,
    Traversable,
 )

type Program = Program' BNFC'Position
data Program' a = Program a [TopDef' a]
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TopDef = TopDef' BNFC'Position
data TopDef' a
    = TDFunction a (Type' a) Ident [FunctionArg' a] (StmtBlock' a)
    | TDClass a Ident (ClassDerivation' a) (ClassBlock' a)
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunctionArg = FunctionArg' BNFC'Position
data FunctionArg' a = FArg a (Type' a) Ident
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ClassDerivation = ClassDerivation' BNFC'Position
data ClassDerivation' a = CDerive a Ident | CNoDerive a
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ClassBlock = ClassBlock' BNFC'Position
data ClassBlock' a = ClassBlock a [ClassElem' a]
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ClassElem = ClassElem' BNFC'Position
data ClassElem' a
    = CEMethod a (Type' a) Ident [FunctionArg' a] (StmtBlock' a)
    | CEField a (Type' a) Ident
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type StmtBlock = StmtBlock' BNFC'Position
data StmtBlock' a = StmtBlock a [Stmt' a]
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Stmt = Stmt' BNFC'Position
data Stmt' a
    = SEmpty a
    | SBlock a (StmtBlock' a)
    | SDecl a (Type' a) [Declaration' a]
    | SAss a Ident (Expr' a)
    | SIncr a Ident
    | SDecr a Ident
    | SRet a (Expr' a)
    | SVRet a
    | SCond a (Expr' a) (Stmt' a)
    | SCondElse a (Expr' a) (Stmt' a) (Stmt' a)
    | SWhile a (Expr' a) (Stmt' a)
    | SFor a (Type' a) Ident (Expr' a) (Stmt' a)
    | SExp a (Expr' a)
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Declaration = Declaration' BNFC'Position
data Declaration' a
    = DeclNoInit a Ident
    | DeclInit a Ident (Expr' a)
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Type = Type' BNFC'Position
data Type' a
    = TInt a
    | TStr a
    | TBool a
    | TVoid a
    | TClass a Ident
    | TArr a (Type' a)
    | TFun a (Type' a) [Type' a]
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Expr = Expr' BNFC'Position
data Expr' a
    = EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EString a String
    | ENeg a (Expr' a)
    | ENot a (Expr' a)
    | EMul a (Expr' a) (OpMul' a) (Expr' a)
    | EAdd a (Expr' a) (OpAdd' a) (Expr' a)
    | ERel a (Expr' a) (OpRel' a) (Expr' a)
    | EAnd a (Expr' a) (Expr' a)
    | EOr a (Expr' a) (Expr' a)
    | ENullReg a Ident
    | ENullArr a Ident
    | ENull a (Type' a)
    | ENew a (Type' a)
    | ENewArr a (Type' a) (Expr' a)
    | EApp a (Expr' a) [Expr' a]
    | EMember a (Expr' a) Ident
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Epxr = Epxr' BNFC'Position
data Epxr' a = EArrAcc a (Expr' a) [Expr' a]
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type OpAdd = OpAdd' BNFC'Position
data OpAdd' a = Plus a | Minus a
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type OpMul = OpMul' BNFC'Position
data OpMul' a = Times a | Div a | Mod a
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type OpRel = OpRel' BNFC'Position
data OpRel' a = LTH a | LE a | GTH a | GE a | EQU a | NE a
    deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
    deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.
type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.
class HasPosition a where
    hasPosition :: a -> BNFC'Position

instance HasPosition Program where
    hasPosition = \case
        Program p _ -> p

instance HasPosition TopDef where
    hasPosition = \case
        TDFunction p _ _ _ _ -> p
        TDClass p _ _ _ -> p

instance HasPosition FunctionArg where
    hasPosition = \case
        FArg p _ _ -> p

instance HasPosition ClassDerivation where
    hasPosition = \case
        CDerive p _ -> p
        CNoDerive p -> p

instance HasPosition ClassBlock where
    hasPosition = \case
        ClassBlock p _ -> p

instance HasPosition ClassElem where
    hasPosition = \case
        CEMethod p _ _ _ _ -> p
        CEField p _ _ -> p

instance HasPosition StmtBlock where
    hasPosition = \case
        StmtBlock p _ -> p

instance HasPosition Stmt where
    hasPosition = \case
        SEmpty p -> p
        SBlock p _ -> p
        SDecl p _ _ -> p
        SAss p _ _ -> p
        SIncr p _ -> p
        SDecr p _ -> p
        SRet p _ -> p
        SVRet p -> p
        SCond p _ _ -> p
        SCondElse p _ _ _ -> p
        SWhile p _ _ -> p
        SFor p _ _ _ _ -> p
        SExp p _ -> p

instance HasPosition Declaration where
    hasPosition = \case
        DeclNoInit p _ -> p
        DeclInit p _ _ -> p

instance HasPosition Type where
    hasPosition = \case
        TInt p -> p
        TStr p -> p
        TBool p -> p
        TVoid p -> p
        TClass p _ -> p
        TArr p _ -> p
        TFun p _ _ -> p

instance HasPosition Expr where
    hasPosition = \case
        EVar p _ -> p
        ELitInt p _ -> p
        ELitTrue p -> p
        ELitFalse p -> p
        EString p _ -> p
        ENeg p _ -> p
        ENot p _ -> p
        EMul p _ _ _ -> p
        EAdd p _ _ _ -> p
        ERel p _ _ _ -> p
        EAnd p _ _ -> p
        EOr p _ _ -> p
        ENullReg p _ -> p
        ENullArr p _ -> p
        ENull p _ -> p
        ENew p _ -> p
        ENewArr p _ _ -> p
        EApp p _ _ -> p
        EMember p _ _ -> p

instance HasPosition Epxr where
    hasPosition = \case
        EArrAcc p _ _ -> p

instance HasPosition OpAdd where
    hasPosition = \case
        Plus p -> p
        Minus p -> p

instance HasPosition OpMul where
    hasPosition = \case
        Times p -> p
        Div p -> p
        Mod p -> p

instance HasPosition OpRel where
    hasPosition = \case
        LTH p -> p
        LE p -> p
        GTH p -> p
        GE p -> p
        EQU p -> p
        NE p -> p
